# Java数据类型与类型转换详解

## 一、Java数据类型分类

Java数据类型分为两大类：**基本数据类型**和**引用数据类型**

### 1.1 基本数据类型（Primitive Types）

#### 整数类型

| 类型  | 字节数 | 位数 | 取值范围                                               | 默认值 |
| ----- | ------ | ---- | ------------------------------------------------------ | ------ |
| byte  | 1      | 8    | -128 ~ 127                                             | 0      |
| short | 2      | 16   | -32,768 ~ 32,767                                       | 0      |
| int   | 4      | 32   | -2,147,483,648 ~ 2,147,483,647                         | 0      |
| long  | 8      | 64   | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0L     |

#### 浮点类型

| 类型   | 字节数 | 位数 | 精度     | 取值范围  | 默认值 |
| ------ | ------ | ---- | -------- | --------- | ------ |
| float  | 4      | 32   | 7位小数  | ±3.4E+38  | 0.0f   |
| double | 8      | 64   | 15位小数 | ±1.7E+308 | 0.0d   |

#### 字符类型

| 类型 | 字节数 | 位数 | 取值范围            | 默认值   |
| ---- | ------ | ---- | ------------------- | -------- |
| char | 2      | 16   | 0 ~ 65535 (Unicode) | '\u0000' |

#### 布尔类型

| 类型    | 字节数 | 取值       | 默认值 |
| ------- | ------ | ---------- | ------ |
| boolean | 1      | true/false | false  |

### 1.2 引用数据类型（Reference Types）

- **类（Class）**：如String、自定义类
- **接口（Interface）**：如List、Map等
- **数组（Array）**：如int[]、String[]等
- **枚举（Enum）**：枚举类型

## 二、数据类型转换

### 2.1 自动类型转换（隐式转换）

**转换规则**：从小范围到大范围的转换会自动进行

**转换路径**：

```
byte → short → int → long → float → double
         ↑
       char
```

**示例代码**：

```java
byte b = 10;
int i = b;        // byte自动转为int
long l = i;       // int自动转为long
float f = l;      // long自动转为float
double d = f;     // float自动转为double

char c = 'A';
int ascii = c;    // char自动转为int，得到ASCII值65
```

### 2.2 强制类型转换（显式转换）

**语法**：`(目标类型)变量名`

**示例代码**：

```java
double d = 3.14;
int i = (int)d;           // 结果：3，小数部分被截断

long l = 100L;
int i2 = (int)l;          // 可能数据丢失

float f = 3.14f;
int i3 = (int)f;          // 结果：3

// char与int的相互转换
int num = 65;
char c = (char)num;       // 结果：'A'
char c2 = 'B';
int ascii = (int)c2;      // 结果：66
```

## 三、包装类与自动装箱/拆箱

### 3.1 基本类型对应的包装类

| 基本类型 | 包装类    |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

### 3.2 自动装箱与拆箱

**自动装箱**：基本类型自动转为包装类

```java
Integer i = 10;           // 相当于 Integer i = Integer.valueOf(10);
Double d = 3.14;          // 相当于 Double d = Double.valueOf(3.14);
```

**自动拆箱**：包装类自动转为基本类型

```java
Integer i = 100;
int primitive = i;        // 相当于 int primitive = i.intValue();
```

## 四、字符串转换

### 4.1 基本类型转字符串

```java
// 方法一：使用 + 操作符
int i = 123;
String s1 = i + "";

// 方法二：使用String.valueOf()
String s2 = String.valueOf(i);

// 方法三：使用包装类的toString()
String s3 = Integer.toString(i);
```

### 4.2 字符串转基本类型

```java
String s = "123";

// 转换为各种基本类型
int i = Integer.parseInt(s);
long l = Long.parseLong(s);
float f = Float.parseFloat("3.14");
double d = Double.parseDouble("3.14");
boolean b = Boolean.parseBoolean("true");

// 使用包装类的valueOf方法
Integer integer = Integer.valueOf(s);
Double doubleObj = Double.valueOf("3.14");
```

## 五、重要注意事项

### 5.1 精度丢失问题

```java
// float和double的精度问题
float f1 = 0.1f;
float f2 = 0.2f;
System.out.println(f1 + f2);  // 输出：0.30000001，不是0.3

// 大整数转换为float的精度丢失
long bigLong = 123456789012345L;
float f = bigLong;
System.out.println((long)f);   // 可能不等于原值
```

### 5.2 数据溢出问题

```java
// int溢出
int max = Integer.MAX_VALUE;
int overflow = max + 1;
System.out.println(overflow);  // 输出：-2147483648

// byte溢出
byte b = 127;
b++;                          // 编译错误！需要强制转换
b = (byte)(b + 1);           // 结果：-128
```

### 5.3 char类型特殊性

```java
// char是无符号16位整数
char c1 = 'A';               // 正确
char c2 = 65;                // 正确，ASCII值
char c3 = -1;                // 编译错误！char不能为负数

// char的运算
char c = 'A';
System.out.println(c + 1);   // 输出：66，自动转为int
System.out.println((char)(c + 1)); // 输出：'B'
```

### 5.4 自动装箱的缓存机制

```java
// Integer缓存-128到127
Integer i1 = 127;
Integer i2 = 127;
System.out.println(i1 == i2); // true

Integer i3 = 128;
Integer i4 = 128;
System.out.println(i3 == i4); // false，需要用equals比较

// 正确的比较方式
System.out.println(i3.equals(i4)); // true
```

### 5.5 运算中的类型提升

```java
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2;        // 编译错误！
int result = b1 + b2;        // 正确，byte运算会提升为int

short s1 = 100;
short s2 = 200;
// short s3 = s1 + s2;       // 编译错误！
int result2 = s1 + s2;       // 正确
```

### 5.6 字符串转换异常处理

```java
try {
    int i = Integer.parseInt("abc");  // 抛出NumberFormatException
} catch (NumberFormatException e) {
    System.out.println("转换失败：" + e.getMessage());
}

// 安全的转换方法
public static Integer safeParseInt(String str) {
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException e) {
        return null;  // 或返回默认值
    }
}
```

## 六、建议

1. **优先使用基本类型**：性能更好，占用内存更少
2. **注意精度问题**：金融计算使用BigDecimal而不是float/double
3. **避免不必要的装箱拆箱**：频繁操作会影响性能
4. **字符串转换要处理异常**：防止NumberFormatException
5. **比较包装类使用equals**：避免使用==比较
6. **了解取值范围**：防止溢出问题
7. **char类型当作数字使用时要小心**：记住它是无符号的

## 七、常见错误总结

1. 将大类型赋值给小类型时忘记强制转换
2. 混淆==和equals的使用场景
3. 忽略运算时的自动类型提升
4. 不处理字符串转换的异常
5. 不了解浮点数的精度限制
6. 忘记long常量要加L后缀，float常量要加f后缀