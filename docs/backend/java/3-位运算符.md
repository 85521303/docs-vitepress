# 位运算符原理详解

## 一、数字在计算机中的表示方法

### 1.1 原码（Sign-Magnitude）

**定义**：最高位表示符号位（0为正，1为负），其余位表示数值的绝对值

**示例**（以8位为例）：

```
+5 的原码：0000 0101
-5 的原码：1000 0101
+0 的原码：0000 0000
-0 的原码：1000 0000  ← 存在+0和-0两种表示
```

**问题**：

- 存在+0和-0两种表示，浪费存储空间
- 加法运算复杂，需要判断符号

### 1.2 反码（One's Complement）

**定义**：

- 正数的反码与原码相同
- 负数的反码是对原码除符号位外的所有位取反

**示例**（以8位为例）：

```
+5 的反码：0000 0101  （与原码相同）
-5 的反码：1111 1010  （对原码1000 0101除符号位外取反）
+0 的反码：0000 0000
-0 的反码：1111 1111  ← 仍然存在+0和-0
```

**问题**：

- 仍然存在+0和-0的问题
- 运算时需要处理进位

### 1.3 补码（Two's Complement）

**定义**：

- 正数的补码与原码相同
- 负数的补码是对反码+1，或者对原码除符号位外所有位取反再+1

**示例**（以8位为例）：

```
+5 的补码：0000 0101  （与原码相同）
-5 的补码：1111 1011  （反码1111 1010 + 1）
+0 的补码：0000 0000
-0 的补码：0000 0000  ← 只有一种0的表示
```

**优势**：

- 统一了0的表示
- 简化了加减法运算
- 现代计算机普遍采用补码表示

### 1.4 补码的快速计算方法

**方法一**：反码+1

```
-5: 原码 1000 0101 → 反码 1111 1010 → 补码 1111 1011
```

**方法二**：从右往左找到第一个1，该位及右边保持不变，左边全部取反

```
原码：1000 0101
      ↑   ↑ 第一个1
补码：1111 1011
```

## 二、位运算符详解

### 2.1 按位与（&）

**原理**：两个位都为1时结果为1，否则为0

**真值表**：

```
A | B | A&B
--|---|----
0 | 0 |  0
0 | 1 |  0
1 | 0 |  0
1 | 1 |  1
```

**示例**：

```java
int a = 5;    // 0000 0101
int b = 3;    // 0000 0011
int c = a & b; // 0000 0001 = 1
```

**应用场景**：

- **获取特定位**：`value & (1 << n)` 获取第n位
- **清零特定位**：`value & ~(1 << n)` 将第n位清零
- **判断奇偶**：`n & 1` 为1则奇数，为0则偶数

### 2.2 按位或（|）

**原理**：两个位有一个为1时结果为1，都为0时为0

**真值表**：

```
A | B | A|B
--|---|----
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  1
```

**示例**：

```java
int a = 5;    // 0000 0101
int b = 3;    // 0000 0011
int c = a | b; // 0000 0111 = 7
```

**应用场景**：

- **设置特定位**：`value | (1 << n)` 将第n位设为1
- **合并标志位**：权限控制、状态标记

### 2.3 按位异或（^）

**原理**：两个位相同为0，不同为1

**真值表**：

```
A | B | A^B
--|---|----
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  0
```

**示例**：

```java
int a = 5;    // 0000 0101
int b = 3;    // 0000 0011
int c = a ^ b; // 0000 0110 = 6
```

**重要性质**：

- **交换律**：a ^ b = b ^ a
- **结合律**：(a ^ b) ^ c = a ^ (b ^ c)
- **自反性**：a ^ a = 0
- **恒等性**：a ^ 0 = a

**应用场景**：

- **无临时变量交换**：

```java
a = a ^ b;
b = a ^ b;  // b = (a^b)^b = a^(b^b) = a^0 = a
a = a ^ b;  // a = (a^b)^a = (a^a)^b = 0^b = b
```

- **翻转特定位**：`value ^ (1 << n)` 翻转第n位
- **加密解密**：相同密钥异或两次回到原值

### 2.4 按位取反（~）

**原理**：每一位都取反，0变1，1变0

**示例**：

```java
int a = 5;     // 0000 0101
int b = ~a;    // 1111 1010 = -6（补码表示）
```

**补码计算过程**：

```
原数：  5 = 0000 0101
取反：     1111 1010  ← 这是-6的补码
验证-6的补码：
-6原码：1000 0110
-6反码：1111 1001
-6补码：1111 1010  ✓
```

**重要公式**：`~n = -(n+1)`

### 2.5 左移运算符（<<）

**原理**：将二进制位向左移动，右边补0

**示例**：

```java
int a = 5;      // 0000 0101
int b = a << 2; // 0001 0100 = 20
```

**数学意义**：左移n位相当于乘以2^n

**注意事项**：

- 可能发生溢出
- 符号位也会参与移位

### 2.6 右移运算符（>>）

**原理**：将二进制位向右移动

**算术右移（>>）**：

- 正数：左边补0
- 负数：左边补1（保持符号）

**示例**：

```java
int a = 20;     // 0001 0100
int b = a >> 2; // 0000 0101 = 5

int c = -8;     // 1111 1000（-8的补码）
int d = c >> 2; // 1111 1110 = -2（补1保持负号）
```

### 2.7 无符号右移（>>>）

**原理**：无论正负数，左边都补0

**示例**：

```java
int a = -8;      // 1111 1111 1111 1111 1111 1111 1111 1000
int b = a >>> 2; // 0011 1111 1111 1111 1111 1111 1111 1110
// 结果是一个很大的正数：1073741822
```

## 三、位运算在不同进制中的应用

### 3.1 补码的位运算示例

**8位补码加法**：

```
  5 + (-3) = 2
  0000 0101  (+5的补码)
+ 1111 1101  (-3的补码：原码1000 0011→反码1111 1100→补码1111 1101)
-----------
  0000 0010  (结果为+2，进位舍弃)
```

**验证-3的补码**：

```
-3原码：1000 0011
-3反码：1111 1100（符号位不变，其他位取反）
-3补码：1111 1101（反码+1）
```

### 3.2 溢出处理

**8位有符号数范围**：-128 ~ +127

**溢出示例**：

```java
byte a = 127;   // 0111 1111
byte b = 1;     // 0000 0001
// a + b = 128，但8位有符号数无法表示128
// 结果：1000 0000 = -128（发生溢出）
```

## 四、位运算的高级应用

### 4.1 位掩码（Bit Mask）

**权限系统示例**：

```java
// 定义权限常量
final int READ = 1;    // 0001
final int WRITE = 2;   // 0010
final int EXECUTE = 4; // 0100
final int DELETE = 8;  // 1000

// 设置权限
int permission = READ | WRITE | EXECUTE; // 0111 = 7

// 检查权限
boolean canRead = (permission & READ) != 0;     // true
boolean canDelete = (permission & DELETE) != 0; // false

// 添加权限
permission |= DELETE; // 1111 = 15

// 移除权限
permission &= ~WRITE; // 1101 = 13
```

### 4.2 位运算优化技巧

**1. 快速乘除2的幂次**：

```java
// 乘法
int result = n << 3;  // n * 8

// 除法
int result = n >> 2;  // n / 4（正数）
```

**2. 判断2的幂次**：

```java
boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
// 原理：2的幂次只有一个1位，n-1会使该位及右边全部翻转
// 例：8(1000) & 7(0111) = 0
```

**3. 统计1的个数**：

```java
int countOnes(int n) {
    int count = 0;
    while (n != 0) {
        count++;
        n &= (n - 1);  // 清除最右边的1
    }
    return count;
}
```

**4. 获取最右边的1**：

```java
int rightmostOne(int n) {
    return n & (-n);
}
// 原理：-n是n的补码，n & (-n)只保留最右边的1
```

### 4.3 位运算与性能

**优势**：

- 直接操作二进制位，速度快
- 占用内存少
- 某些算法用位运算更简洁

**注意事项**：

- 可读性较差，需要注释
- 容易出错，需要仔细测试
- 过度优化可能影响代码维护

## 五、常见错误与注意事项

### 5.1 符号扩展问题

```java
byte b = -1;              // 1111 1111
int i = b;                // 1111 1111 1111 1111 1111 1111 1111 1111
int unsigned = b & 0xFF;  // 0000 0000 0000 0000 0000 0000 1111 1111 = 255
```

### 5.2 移位运算的边界

```java
int a = 1;
int b = a << 32;  // 结果可能不是预期的，因为只取低5位
// 实际相当于 a << 0 = 1
```

### 5.3 优先级问题

```java
// 错误：位运算优先级低于比较运算符
if (flags & MASK == MASK) // 相当于 flags & (MASK == MASK)

// 正确：加括号
if ((flags & MASK) == MASK)
```

## 六、实际应用场景总结

1. **状态管理**：使用位标志表示多种状态
2. **权限控制**：每一位表示一种权限
3. **数据压缩**：在有限空间内存储更多信息
4. **算法优化**：某些算法用位运算性能更好
5. **加密解密**：XOR运算在简单加密中的应用
6. **图形处理**：颜色值、像素操作
7. **网络编程**：IP地址处理、协议解析

位运算虽然看起来复杂，但掌握了原码、反码、补码的概念后，理解起来就会容易很多。在实际编程中，合理使用位运算可以让代码更高效、更简洁。