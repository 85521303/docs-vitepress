# 1. 使用结构体模拟类

~~~c
// 定义"类"结构体
typedef struct {
    int x, y;
    void (*move)(struct Point* self, int dx, int dy);
    void (*print)(struct Point* self);
} Point;

// "方法"实现
void point_move(Point* self, int dx, int dy) {
    self->x += dx;
    self->y += dy;
}

void point_print(Point* self) {
    printf("Point(%d, %d)\n", self->x, self->y);
}

// "构造函数"
Point* point_create(int x, int y) {
    Point* p = malloc(sizeof(Point));
    p->x = x;
    p->y = y;
    p->move = point_move;
    p->print = point_print;
    return p;
}
~~~

# 2. 封装和数据隐藏

通过头文件和实现文件分离来实现封装：

**point.h**

~~~c
#ifndef POINT_H
#define POINT_H

typedef struct Point Point; // 前置声明，隐藏内部结构

Point* point_create(int x, int y);
void point_destroy(Point* p);
void point_move(Point* p, int dx, int dy);
void point_get_coords(Point* p, int* x, int* y);

#endif
~~~

**point.c**

~~~c
#include "point.h"

struct Point {
    int x, y; // 私有成员，外部无法直接访问
};

Point* point_create(int x, int y) {
    Point* p = malloc(sizeof(Point));
    p->x = x;
    p->y = y;
    return p;
}

void point_move(Point* p, int dx, int dy) {
    p->x += dx;
    p->y += dy;
}
~~~

# 模拟继承

~~~c
// 基类
typedef struct {
    char name[50];
    void (*speak)(void* self);
} Animal;

// 派生类
typedef struct {
    Animal base; // 继承基类
    int age;
} Dog;

typedef struct {
    Animal base;
    int lives;
} Cat;

// 基类方法
void animal_speak(void* self) {
    Animal* animal = (Animal*)self;
    printf("%s makes a sound\n", animal->name);
}

// 派生类方法（重写）
void dog_speak(void* self) {
    Dog* dog = (Dog*)self;
    printf("%s barks\n", dog->base.name);
}

void cat_speak(void* self) {
    Cat* cat = (Cat*)self;
    printf("%s meows\n", cat->base.name);
}

// 构造函数
Dog* dog_create(const char* name, int age) {
    Dog* dog = malloc(sizeof(Dog));
    strcpy(dog->base.name, name);
    dog->base.speak = dog_speak; // 设置虚函数
    dog->age = age;
    return dog;
}
~~~

# 模拟多态

~~~c
// 使用函数指针实现多态
void make_animal_speak(Animal* animal) {
    animal->speak(animal); // 调用对应的实现
}

int main() {
    Dog* dog = dog_create("Buddy", 3);
    Cat* cat = cat_create("Whiskers", 2);
    
    // 多态调用
    make_animal_speak((Animal*)dog); // 输出: Buddy barks
    make_animal_speak((Animal*)cat); // 输出: Whiskers meows
    
    return 0;
}
~~~

# 模拟接口

~~~c
// 定义接口（函数指针结构）
typedef struct {
    void (*draw)(void* self);
    double (*area)(void* self);
} Drawable;

// 圆形实现
typedef struct {
    Drawable interface;
    double radius;
} Circle;

void circle_draw(void* self) {
    Circle* c = (Circle*)self;
    printf("Drawing circle with radius %.2f\n", c->radius);
}

double circle_area(void* self) {
    Circle* c = (Circle*)self;
    return 3.14159 * c->radius * c->radius;
}

Circle* circle_create(double radius) {
    Circle* c = malloc(sizeof(Circle));
    c->interface.draw = circle_draw;
    c->interface.area = circle_area;
    c->radius = radius;
    return c;
}
~~~

# 完整示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ========== 基类 Animal ==========
typedef struct Animal Animal;

typedef struct {
    void (*speak)(Animal* self);
    void (*move)(Animal* self);
    void (*destroy)(Animal* self);
} AnimalVTable;

struct Animal {
    AnimalVTable* vtable;
    char name[50];
    int age;
};

// Animal 基类方法
void animal_speak(Animal* self) {
    printf("%s makes a sound\n", self->name);
}

void animal_move(Animal* self) {
    printf("%s is moving\n", self->name);
}

void animal_destroy(Animal* self) {
    printf("Destroying animal %s\n", self->name);
    free(self);
}

// Animal 虚函数表
static AnimalVTable animal_vtable = {
    .speak = animal_speak,
    .move = animal_move,
    .destroy = animal_destroy
};

// Animal 构造函数
Animal* animal_create(const char* name, int age) {
    Animal* animal = malloc(sizeof(Animal));
    animal->vtable = &animal_vtable;
    strcpy(animal->name, name);
    animal->age = age;
    return animal;
}

// ========== 派生类 Dog ==========
typedef struct {
    Animal base;  // 继承
    char breed[30];
} Dog;

// Dog 方法（重写）
void dog_speak(Animal* self) {
    Dog* dog = (Dog*)self;
    printf("%s (breed: %s) barks: Woof!\n", self->name, dog->breed);
}

void dog_move(Animal* self) {
    printf("%s runs happily\n", self->name);
}

void dog_destroy(Animal* self) {
    printf("Destroying dog %s\n", self->name);
    free(self);
}

// Dog 虚函数表
static AnimalVTable dog_vtable = {
    .speak = dog_speak,
    .move = dog_move,
    .destroy = dog_destroy
};

// Dog 构造函数
Dog* dog_create(const char* name, int age, const char* breed) {
    Dog* dog = malloc(sizeof(Dog));
    dog->base.vtable = &dog_vtable;
    strcpy(dog->base.name, name);
    dog->base.age = age;
    strcpy(dog->breed, breed);
    return dog;
}

// Dog 特有方法
void dog_fetch(Dog* self) {
    printf("%s is fetching the ball!\n", self->base.name);
}

// ========== 派生类 Cat ==========
typedef struct {
    Animal base;
    int lives;
} Cat;

// Cat 方法（重写）
void cat_speak(Animal* self) {
    Cat* cat = (Cat*)self;
    printf("%s meows: Meow! (has %d lives left)\n", self->name, cat->lives);
}

void cat_move(Animal* self) {
    printf("%s prowls silently\n", self->name);
}

void cat_destroy(Animal* self) {
    printf("Destroying cat %s\n", self->name);
    free(self);
}

// Cat 虚函数表
static AnimalVTable cat_vtable = {
    .speak = cat_speak,
    .move = cat_move,
    .destroy = cat_destroy
};

// Cat 构造函数
Cat* cat_create(const char* name, int age, int lives) {
    Cat* cat = malloc(sizeof(Cat));
    cat->base.vtable = &cat_vtable;
    strcpy(cat->base.name, name);
    cat->base.age = age;
    cat->lives = lives;
    return cat;
}

// Cat 特有方法
void cat_climb(Cat* self) {
    printf("%s climbs the tree\n", self->base.name);
}

// ========== 多态函数 ==========
void animal_do_actions(Animal* animal) {
    printf("=== Actions for %s ===\n", animal->name);
    animal->vtable->speak(animal);  // 多态调用
    animal->vtable->move(animal);   // 多态调用
    printf("\n");
}

void animal_cleanup(Animal* animal) {
    animal->vtable->destroy(animal); // 多态析构
}

// ========== 主函数 ==========
int main() {
    printf("C Language Object-Oriented Programming Demo\n");
    printf("============================================\n\n");
    
    // 创建对象
    Animal* generic_animal = animal_create("Generic", 5);
    Dog* my_dog = dog_create("Buddy", 3, "Golden Retriever");
    Cat* my_cat = cat_create("Whiskers", 2, 9);
    
    // 多态数组
    Animal* animals[] = {
        generic_animal,
        (Animal*)my_dog,    // 向上转型
        (Animal*)my_cat     // 向上转型
    };
    
    int num_animals = sizeof(animals) / sizeof(animals[0]);
    
    // 多态调用
    printf("Demonstrating polymorphism:\n");
    for (int i = 0; i < num_animals; i++) {
        animal_do_actions(animals[i]);
    }
    
    // 调用派生类特有方法
    printf("Calling derived class specific methods:\n");
    dog_fetch(my_dog);
    cat_climb(my_cat);
    printf("\n");
    
    // 展示封装 - 通过方法访问数据
    printf("Animal information (encapsulated access):\n");
    printf("Dog name: %s, age: %d\n", my_dog->base.name, my_dog->base.age);
    printf("Cat name: %s, age: %d\n", my_cat->base.name, my_cat->base.age);
    printf("\n");
    
    // 清理资源（多态析构）
    printf("Cleaning up resources:\n");
    for (int i = 0; i < num_animals; i++) {
        animal_cleanup(animals[i]);
    }
    
    return 0;
}
~~~

